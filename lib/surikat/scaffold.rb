module Scaffold

  require 'fileutils'

  def generate_routes(model_name)
    print "Generating query and migration routes... "

    routes = Routes.new

    class_name = ActiveSupport::Inflector.singularize(model_name.capitalize)

    begin
      # get one query
      routes.merge_query({class_name => {
          'module'      => "#{class_name}Queries",
          'method'      => 'get',
          'output_type' => "#{class_name}",
          'arguments'   => {'id' => 'ID'}
      }})

      # get all query
      class_name_plural = ActiveSupport::Inflector.pluralize(class_name)
      routes.merge_query({class_name_plural => {
          'module'      => "#{class_name}Queries",
          'method'      => 'all',
          'output_type' => "[#{class_name}]",
          'arguments'   => {}
      }})

      # create mutation
      routes.merge_mutation({class_name => {
          'module'      => "#{class_name}Queries",
          'method'      => 'create',
          'output_type' => "#{class_name}",
          'arguments'   => {'author' => 'AuthorInput'}
      }})

      # update mutation
      routes.merge_mutation({"Update#{class_name}" => {
          'module'      => "#{class_name}Queries",
          'method'      => 'update',
          'output_type' => "Boolean",
          'arguments'   => {'author' => 'AuthorInput'}
      }})

      # delete mutation
      routes.merge_mutation({"Delete#{class_name}" => {
          'module'      => "#{class_name}Queries",
          'method'      => 'delete',
          'output_type' => "Boolean",
          'arguments'   => {'id' => 'ID'}
      }})
    rescue Exception => e
      puts "fail: #{e.message}, #{e.backtrace.first}"
      false
    else
      puts "ok"
      true
    end
  end

  def destroy_routes(model_name)
    class_name        = ActiveSupport::Inflector.singularize(model_name.capitalize)
    class_name_plural = ActiveSupport::Inflector.pluralize(class_name)

    routes = Routes.new

    print "Destroying query and mutation routes... "

    begin
      routes.delete_query class_name
      routes.delete_query class_name_plural
      routes.delete_mutation class_name
      routes.delete_mutation "Update#{class_name}"
      routes.delete_mutation "Delete#{class_name}"
    rescue Exception => e
      puts "fail: #{e.message}, #{e.backtrace.first}"
      false
    else
      puts "ok"
      true
    end
  end

  def generate_queries(model_name)
    var_name           = ActiveSupport::Inflector.singularize(model_name.downcase)
    class_name         = ActiveSupport::Inflector.singularize(model_name.capitalize)
    class_name_plural  = ActiveSupport::Inflector.pluralize(class_name)
    file_name          = ActiveSupport::Inflector.singularize(model_name.downcase) + '_queries.rb'
    file_path          = "queries/#{file_name}"
    absolute_path      = File.expand_path('.', __dir__) + '/../../'
    file_absolute_path = absolute_path + file_path

    FileUtils.mkdir_p absolute_path + 'models'

    print "Generating query file #{file_path}... "

    if File.exists?(file_absolute_path)
      puts "exists"
      return true
    end

    all_types = Types.new.all

    input_type_detailed = all_types["#{class_name}Input"]['arguments'].map do |field, type|
      "   '#{field}' => #{type}"
    end.join("\n")

    input_type_detailed_no_id = all_types["#{class_name}Input"]['arguments'].map do |field, type|
      next if field == 'id'
      "   '#{field}' => #{type}"
    end.compact.join("\n")

    fields = all_types[class_name]['fields'].keys

    examples = {
        get:    "{\n  #{class_name}(id: 123) {\n" + fields.map {|f| "    #{f}"}.join("\n") + "\n  }\n}",
        list:   "{\n  #{class_name_plural} {\n" + fields.map {|f| "    #{f}"}.join("\n") + "\n  }\n}",
        create: "mutation #{class_name}($#{var_name}: #{class_name}Input) {\n  #{class_name}(#{var_name}: $#{var_name}) {\n" + fields.map {|f| "    #{f}"}.join("\n") + "\n  }\n}",
        update: "mutation Update#{class_name}($#{var_name}: #{class_name}Input) {\n  Update#{class_name}(#{var_name}: $#{var_name}) {\n" + fields.map {|f| "    #{f}"}.join("\n") + "\n  }\n}",
        delete: "mutation Delete#{class_name}($id: ID) {\n  Delete#{class_name}(id: $id)\n}"
    }

    update_vars = {var_name => {}}
    all_types["#{class_name}Input"]['arguments'].each {|a, t| update_vars[var_name][a] = random_values(t)}

    create_vars = {var_name => {}}
    all_types["#{class_name}Input"]['arguments'].each {|a, t| create_vars[var_name][a] = random_values(t)}
    create_vars[var_name].delete 'id'

    template = <<EOT
=begin
This module was generated by the scaffold generator.
It contains methods to get, list, create, update and delete instances of #{class_name}.
Default routes are created for each of this method (use '#{$0} list routes' or look inside config/routes.json to see them).
Example queries/mutations can be found in the comments for each method.
Generated at:: #{Time.now.to_s}
=end
module Queries

  require File.expand_path('.',__dir__) + '/../models/#{class_name.downcase}'

  module #{class_name}Queries

=begin
Description: Retrieve one #{class_name} instance by its id
Query Name: #{class_name}

Input: { 'id' => ID }

Output Type: #{class_name}

Query Example:
#{examples[:get]}
=end
    def self.get(arguments)
      #{class_name}.where(id: arguments['id'])
    end

=begin
Description: Retrieve all #{class_name} instances
Query Name: #{class_name_plural}

Input: none

Output Type: [#{class_name}]

Query Example:
#{examples[:list]}
=end
    def self.all(_arguments)
      #{class_name}.all
    end

=begin
Description: Create an instance of #{class_name} and return it; this is a mutation.
Mutation Name: #{class_name}

Input: { '#{class_name}' => {
#{input_type_detailed_no_id}
  }
}

Output Type: #{class_name}

Query Example:
#{examples[:create]}

Example Variables:
#{JSON.pretty_generate create_vars}
=end
    def self.create(arguments)
      #{class_name}.create arguments['#{class_name.downcase}']
    end

=begin
Description: Update an instance of #{class_name}; this is a mutation.
Query Name: Update#{class_name}

Input: { '#{class_name}' => {
#{input_type_detailed}
  }
}

Output Type: Boolean

Query Example:
#{examples[:update]}

Example Variables:
#{JSON.pretty_generate update_vars}
=end
    def self.update(arguments)
      #{class_name}.find(arguments['#{class_name.downcase}']['id']).update(arguments['#{class_name.downcase}'].without('id'))
    end

=begin
Description: Delete an instance of #{class_name}.
Query Name: Delete#{class_name}

Input: { 'id' => ID }

OutputType: Boolean

Query Example:
#{examples[:delete]}

Example Variables:
#{JSON.pretty_generate({ 'id' => random_values('ID')}) }
=end
    def self.delete(arguments)
      #{class_name}.where(id: arguments['id']).destroy_all
    end

  end
end
EOT

    begin
      File.open(file_absolute_path, 'w') {|f| f.write template}
    rescue Exception => e
      puts "fail: #{e.message}, #{e.backtrace.first}"
      false
    else
      puts "ok"
      true
    end
  end

  def destroy_queries(model_name)
    file_name = ActiveSupport::Inflector.singularize(model_name.downcase) + '_queries.rb'
    file_path = "queries/#{file_name}"

    print "Deleting queries file: #{file_path}... "

    begin
      File.unlink File.expand_path('.', __dir__) + '/../../' + file_path
    rescue Exception => e
      puts "fail: #{e.message}"
      false
    else
      puts "ok"
      true
    end
  end

  def generate_types(model_name, arguments)
    type_name = ActiveSupport::Inflector.singularize(model_name.capitalize)
    types     = Types.new

    fields = {}
    (arguments + ['id:ID']).each do |arg|
      field_name, field_type = arg.split(':').map(&:strip)

      field_type = 'ID' if field_name[-3,3] == '_id'

      graphql_type = case field_type
                     when 'ID'
                       'ID'
                     when 'integer'
                       'Int'
                     when 'float'
                       'Float'
                     when 'string', 'text'
                       'String'
                     when 'boolean'
                       'Boolean'
                     else
                       'String'
                     end

      fields[field_name] = graphql_type
    end

    print "Generating output type... "

    if types.all.keys.include?(type_name)
      puts "exists"
    else
      begin
        types.merge type_name => {
            'class'  => type_name,
            'type'   => 'Output',
            'fields' => fields
        }
      rescue Exception => e
        puts "fail: #{e.message}, #{e.backtrace.first}"
        return false
      else
        puts "ok"
      end
    end

    print "Generating input type... "

    if types.all.keys.include?("#{type_name}Input")
      puts "exists"
      true
    else
      begin
        types.merge "#{type_name}Input" => {
            'class'     => type_name,
            'type'      => 'Input',
            'arguments' => fields
        }
      rescue Exception => e
        puts "fail: #{e.message}, #{e.backtrace.first}"
        false
      else
        puts "ok"
        true
      end
    end
  end

  def destroy_types(model_name)
    print "Deleting types... "

    begin
      type_name = ActiveSupport::Inflector.singularize(model_name.capitalize)
      types     = Types.new

      types.delete(type_name)
      types.delete("#{type_name}Input")
    rescue Exception => e
      puts "fail: #{e.message}, #{e.backtrace.first}"
      false
    else
      puts "ok"
      true
    end
  end

  def create_db_table(model_name, arguments)
    table_name = ActiveSupport::Inflector.pluralize(model_name.downcase)

    print "Creating table #{table_name}... "

    begin
      ActiveRecord::Migration.verbose = false
      ActiveRecord::Migration.create_table(table_name) do |t|
        arguments.each do |arg|
          field_name, field_type = arg.split(':').map(&:strip)
          t.send(field_type, field_name.to_sym)

          t.datetime :created_at
          t.datetime :updated_at
        end
      end
    rescue Exception => e
      if e.message =~ /already exists/
        puts "exists"
        true
      else
        puts "fail: #{e.message}, #{e.backtrace.first}"
        false
      end
    else
      puts "ok"
      true
    end
  end

  def destroy_db_table(model_name)
    table_name = ActiveSupport::Inflector.pluralize(model_name.downcase)
    print "Dropping table #{table_name}... "

    begin
      ActiveRecord::Migration.verbose = false
      ActiveRecord::Migration.drop_table(table_name)
    rescue Exception => e
      puts "fail: #{e.message}, #{e.backtrace.first}"
      false
    else
      puts "ok"
      true
    end
  end

  def generate_model(model_name, arguments)
    return false unless create_db_table(model_name, arguments)

    class_name         = ActiveSupport::Inflector.singularize(model_name.capitalize)
    file_name          = ActiveSupport::Inflector.singularize(model_name.downcase) + '.rb'
    file_path          = "models/#{file_name}"
    absolute_path      = File.expand_path('.', __dir__) + '/../../'
    file_absolute_path = absolute_path + file_path

    FileUtils.mkdir_p absolute_path + 'models'

    print "Creating model file: #{file_path}... "

    if File.exists?(file_absolute_path)
      puts "exists"
      return true
    end

    template = <<EOT
require File.expand_path('.',__dir__) + '/../gemlib/lib/base_model'
require File.expand_path('.',__dir__) + '/../gemlib/lib/base_type'

# This model class was generated automatically.
class #{class_name} < BaseModel 

  # Add your own validation rules, instance methods, relationships etc.

end
EOT

    begin
      File.open(file_absolute_path, 'w') {|f| f.write template}
    rescue Exception => e
      puts "fail: #{e.message}, #{e.backtrace.first}"
      false
    else
      puts "ok"
      true
    end
  end

  def destroy_model(model_name)
    return false unless destroy_db_table(model_name)

    file_name = ActiveSupport::Inflector.singularize(model_name.downcase) + '.rb'
    file_path = "models/#{file_name}"

    print "Deleting model file: #{file_path}... "

    begin
      File.unlink File.expand_path('.', __dir__) + '/../../' + file_path
    rescue Exception => e
      puts "fail: #{e.message}, #{e.backtrace.first}"
      false
    else
      puts "ok"
      true
    end
  end

  def generate_scaffold arguments
    model_name = arguments.shift
    if model_name.to_s.empty?
      puts "Syntax: #{$0} generate scaffold model_name field1:type1 field2:type2..."
      return
    end

    unless model_name =~ /^[\p{L}_][\p{L}\p{N}@$#_]{0,127}$/
      puts "'#{model_name}' does not appear to be a valid."
      return
    end

    valid_types = %w(integer float string boolean date datetime decimal binary bigint primary_key references string text time timestamp)

    arguments.each do |arg|
      field_name, field_type = arg.split(':')
      unless field_name =~ /^[\p{L}_][\p{L}\p{N}@$#_]{0,127}$/
        puts "'#{field_name} does not appear to be valid'"
        return
      end
      unless valid_types.include?(field_type)
        puts "'#{field_type}' does not appear to be valid. Valid field types are: #{valid_types.join(', ')}"
      end
    end

    if generate_model(model_name, arguments) &&
        generate_types(model_name, arguments) &&
        generate_queries(model_name) &&
        generate_routes(model_name)
      puts "Done."
    else
      destroy_model(model_name)
      destroy_types(model_name)
      destroy_queries(model_name)
      destroy_routes(model_name)
    end

  end

  def destroy_scaffold model_name
    if model_name.to_s.empty?
      puts "Syntax: #{$0} generate scaffold model_name field1:type1 field2:type2..."
      return
    end

    destroy_model(model_name)
    destroy_types(model_name)
    destroy_queries(model_name)
    destroy_routes(model_name)

    true
  end


end